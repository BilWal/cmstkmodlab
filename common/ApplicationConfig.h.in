/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
//               Copyright (C) 2011-2021 - The DESY CMS Group                  //
//                           All rights reserved                               //
//                                                                             //
//      The CMStkModLab source code is licensed under the GNU GPL v3.0.        //
//      You have the right to modify and/or redistribute this source code      //
//      under the terms specified in the license, which may be found online    //
//      at http://www.gnu.org/licenses or at License.txt.                      //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////

#ifndef APPLICATIONCONFIG_H
#define APPLICATIONCONFIG_H

#include <string>
#include <sstream>
#include <map>
#include <vector>
#include <array>
#include <iomanip>

#include <QObject>
#include <QVariant>
#include <QMessageBox>

/** @addtogroup common
 *  @{
 */

namespace Config {
  extern const std::string CMSTkModLabBasePath;
}

class ApplicationConfig : public QObject
{
  Q_OBJECT
public:

  typedef std::map<std::string,std::vector<std::string> > storage_t;

  static ApplicationConfig* instance(const std::string filename = std::string(), QObject *parent = 0);

  template <class aType> aType getValue(std::string const& key) const {
    aType returnValue = 0;
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      std::istringstream iss(it->second.front().c_str(), std::istringstream::in);
      iss >> returnValue;
    } else {
      issueKeyError(key);
    }
    return returnValue;
  }

  template <class aType> std::vector<aType> getValueVector(std::string const& key) const {
    aType returnValue = 0;
    std::vector<aType> returnVector;
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      for (auto & v : it->second) {
        std::istringstream iss(v.c_str(), std::istringstream::in);
        iss >> returnValue;
        returnVector.push_back(returnValue);
      }
    }
    return returnVector;
  }

  template <class aType,std::size_t N> std::array<aType,N> getValueArray(std::string const& key) const {
    aType returnValue = 0;
    std::array<aType,N> returnArray;
    std::size_t i = 0;
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      for (auto & v : it->second) {
        std::istringstream iss(v.c_str(), std::istringstream::in);
        iss >> returnValue;
        returnArray[i++] = returnValue;
        if (i==N) break;
      }
    }
    return returnArray;
  }

  template <class aType> aType getValue(std::string const& key, aType defaultValue) const {
    aType returnValue = defaultValue;
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      std::istringstream iss(it->second.front().c_str(), std::istringstream::in);
      iss >> returnValue;
    }
    return returnValue;
  }

  std::string getValue(std::string const& key) const {
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      return it->second.front();
    }
    return std::string();
  }
 
  std::string getValueByIndex(std::string const& key, std::size_t idx) const {
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      if (idx<it->second.size()) return it->second[idx];
     }
    return std::string();
  }

  std::vector<std::string> getValueVector(std::string const& key) const {
    std::vector<std::string> returnVector;
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      returnVector = it->second;
    }
    return returnVector;
  }

  std::string getValue(std::string const& key, std::string defaultValue) const {
    storage_t::const_iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      return it->second.front();
    }
    return defaultValue;
  }

  template <class aType> void setValue(std::string const& key, aType value) {
    QVariant variant(value);
    storage_t::iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      keyvalueMap_.erase(key);
      std::vector<std::string> values;
      values.push_back(variant.toString().toStdString());
      keyvalueMap_.insert(std::make_pair(key, values));
      emit valueChanged();
    } else {
      std::vector<std::string> values;
      values.push_back(variant.toString().toStdString());
      keyvalueMap_.insert(std::make_pair(key, values));
      emit structureChanged();
      emit valueChanged();      
    }
  }
 
  void setValueByIndex(std::string const& key, std::size_t idx, std::string& value) {
    storage_t::iterator it = keyvalueMap_.find(key);
    if (it!=keyvalueMap_.end()) {
      if (idx<it->second.size()) {
        it->second[idx] = value;
      	emit valueChanged();
      }
    }
  }

  void safe(const std::string filename);

  const storage_t& getKeyValueMap() { return keyvalueMap_; }
  
  std::vector<std::string> getKeys() {
  	std::vector<std::string> k;
  	for (storage_t::const_iterator it=keyvalueMap_.begin();
  	     it!=keyvalueMap_.end();
  	     ++it) {
      k.push_back(it->first);
    }
    return k;
  }

signals:
  
  void structureChanged();
  void valueChanged();

protected:

  ApplicationConfig(const std::string filename, QObject *parent);
  static ApplicationConfig* instance_;

  void issueKeyError(const std::string&) const;

  storage_t keyvalueMap_;
};

template <> std::string ApplicationConfig::getValue(std::string const& key) const;
template <> std::vector<std::string> ApplicationConfig::getValueVector(std::string const& key) const;
template <> std::string ApplicationConfig::getValue(std::string const& key, std::string defaultValue) const;

template <> int ApplicationConfig::getValue(std::string const& key) const;
template <> std::vector<int> ApplicationConfig::getValueVector(std::string const& key) const;
template <> int ApplicationConfig::getValue(std::string const& key, int defaultValue) const;

template <> unsigned int ApplicationConfig::getValue(std::string const& key) const;
template <> std::vector<unsigned int> ApplicationConfig::getValueVector(std::string const& key) const;
template <> unsigned int ApplicationConfig::getValue(std::string const& key, unsigned int defaultValue) const;

template <> void ApplicationConfig::setValue(std::string const& key, std::string value);

/** @} */

#endif // APPLICATIONCONFIG_H
